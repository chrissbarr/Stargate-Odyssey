<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprController</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*GAMECAVE EFFECTS ENGINE 3.X
Read the GCE3X documentation before using this code!

Object Name - objLens_1
Engine - Lens-Flare Engine 
Purpose - Draws the yellowish-part of the lens-flare.
*/

global.sky_type = 2; //Set this engines sky.
max_flares = 15; //Maximum amount of Flares
min_scale = 0; //Minimum scale for each flare
max_scale = 1; //Maximum scale for each flare
min_alpha = 0.1; //Minimum alpha value for each flare
max_alpha = 0.5; //Maximum alpha value for each flare
flare_shake = 0.1; //The amount the flare 'bobs around'
total_dist = 2000; //How far away the mouse must be for the lens-flare to become invisible. 

//Create an Array for Each flare, giving it random values based upon the above variables.
for (i=1 i&lt;=max_flares i+=1)
{
s1[i]=min_scale+random((max_scale-min_scale));
a1[max_flares+1-i]=(argument4-min_alpha)/max_flares*i;
if a1[i]&gt;max_alpha a1[i]=max_alpha;
if a1[i]&lt;min_alpha a1[i]=min_alpha;
}

x = room_width/2;
y = room_height/2;</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_blend_mode_ext(bm_src_alpha,bm_one); //Set an appropriate blend mode.

dir = point_direction(x,y,mouse_x,mouse_y); //Point towards the mouse
for (i=1; i&lt;=max_flares; i+=1)
{
x1[i]=mouse_x+(sin(degtorad(dir+270))*(distance_to_point(mouse_x,mouse_y)/max_flares*i)); //Add X positions to each flare array index
y1[i]=mouse_y+(cos(degtorad(dir+270))*(distance_to_point(mouse_x,mouse_y)/max_flares*i)); //Add Y positions to each flare array index
}
distscale=power(distance_to_point(mouse_x,mouse_y)/total_dist,4); //Find the scale for the stretching of lens-flare
{
for (i=1 i&lt;=max_flares i+=1) draw_sprite_ext(sprLens_1,0,x1[i],y1[i],s1[i]+random(flare_shake),s1[i]+random(flare_shake),0,c_white,a1[i]+random(0.1)-distscale); //Draw all flares appropriately.
}

draw_set_blend_mode(bm_normal); //Reset blend mode







</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
