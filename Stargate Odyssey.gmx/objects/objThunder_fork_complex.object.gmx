<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*GAMECAVE EFFECTS ENGINE 3.X
Read the GCE3X documentation before using this code!

Object Name - objThunder_fork_complex
Engine - Rain Engine
Purpose - Generates a lightning "shape" and then draws it. This is 
the complex, more realistic type of lightning. It uses primitives and
a few statements to give a realstical approach to the lightning.
*/

alpha = 1; //The alpha of the lightning.
_irr = 40; //The complexity of the lightning; the larger value, the more CPU usage
_ml = 20; //The maximum length of the lightning
_br = 18; //The random change of an irritation having branches.


_x=x;
_y=y;</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>n_br = 0; //Number of branches

//I use 'mb' for the M-ain B-ranch and 'sb' for the branchings
mb_dir = 200+random(140); //Direction of the piece of line
for (i=0;i&lt;_irr;i+=1) {
    mb_x[i] = _x; mb_y[i] = _y; //Position of the irritation; I used 'mb' for the M-ain B-ranch
    _branching = (random(_br)&lt;1); //Whether irritation i has a branching
    if (_branching = true) {
       n_br += 1;
       b_irr[n_br] = random(_irr); //Number of irritations for this branching
       sb_x[n_br,0] = mb_x[i]; sb_y[n_br,0] = mb_y[i]; 
          //Position of the first irritation: the same as the position of the irritation 
          //of the main branch this branching starts on
       
       ///////////
       _c = cos(pi*floor(random(2)));
       if (_c=1) sb_dir = 190+random(60);
       else sb_dir = 350-random(60);
       ////////// This makes the branch going left OR right; not left and later right
       
       for (j=1;j&lt;b_irr[n_br];j+=1) {
           sb_x[n_br,j] = sb_x[n_br,j-1]+lengthdir_x(random(_ml),sb_dir);
           sb_y[n_br,j] = sb_y[n_br,j-1]+lengthdir_y(random(_ml),sb_dir);
           if (_c=1) sb_dir = 190+random(60);
           else sb_dir = 350-random(60);
           }
       }
    _x += lengthdir_x(random(_ml),mb_dir);
    _y += lengthdir_y(random(_ml),mb_dir);
    
    mb_dir = mb_dir-30+random(60);
    if (mb_dir &gt; 340) mb_dir -= random(60);
    if (mb_dir &lt; 200) mb_dir += random(60); //Lightning never goes up, so prevent it from happening
    }
alpha -= 1/9; //Slowly fade out.
if alpha&lt;0{instance_destroy()} //Destroy when faded out.

draw_set_blend_mode(bm_add); //Draw additive-ly
draw_set_color(make_color_rgb(217,160,255)); //Set the colour to a purplish thing.
draw_set_alpha(alpha/2); //Draw the lightning at the specified alpha value.

for (xxx=-1;xxx&lt;=1;xxx+=1) {
    for (yyy=-1;yyy&lt;=1;yyy+=1) {
        
        draw_primitive_begin(pr_linestrip);
        for (i=0;i&lt;_irr;i+=1) {
            draw_vertex(mb_x[i]+xxx,mb_y[i]+yyy);
            }
        draw_primitive_end();

    for (i=1;i&lt;n_br;i+=1) {
        draw_primitive_begin(pr_linestrip);
        for (j=0;j&lt;b_irr[i];j+=1) {
            draw_vertex(sb_x[i,j]+xxx,sb_y[i,j]+yyy);
            }
        draw_primitive_end();
        }
    
    }
}
    
draw_set_alpha(1); //Reset Alpha
draw_set_color(c_white); //Reset colour.</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
